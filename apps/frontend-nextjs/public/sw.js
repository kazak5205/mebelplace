/**
 * Service Worker –¥–ª—è MebelPlace PWA
 * –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ FRONTEND_API_SPECIFICATION.yaml
 */

const CACHE_NAME = 'mebelplace-v1.0.0';
const STATIC_CACHE = 'mebelplace-static-v1.0.0';
const DYNAMIC_CACHE = 'mebelplace-dynamic-v1.0.0';
const API_CACHE = 'mebelplace-api-v1.0.0';

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
const STATIC_ASSETS = [
  '/',
  '/offline',
  '/manifest.json',
  '/icon-192x192.png',
  '/icon-512x512.png',
  '/og-image.jpg',
  '/favicon.ico',
];

// API endpoints –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
const API_ENDPOINTS = [
  '/api/v2/health',
  '/api/v2/live',
  '/api/v2/ready',
];

// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫—ç—à–∞
const MAX_CACHE_SIZE = 50;

// –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Service Worker
self.addEventListener('install', (event) => {
  console.log('Service Worker: Installing...');
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then((cache) => {
        console.log('Service Worker: Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        console.log('Service Worker: Static assets cached successfully');
        return self.skipWaiting();
      })
      .catch((error) => {
        console.error('Service Worker: Failed to cache static assets', error);
      })
  );
});

// –ê–∫—Ç–∏–≤–∞—Ü–∏—è Service Worker
self.addEventListener('activate', (event) => {
  console.log('Service Worker: Activating...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∫—ç—à–∏
            if (cacheName !== STATIC_CACHE && 
                cacheName !== DYNAMIC_CACHE && 
                cacheName !== API_CACHE) {
              console.log('Service Worker: Deleting old cache', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        console.log('Service Worker: Activated successfully');
        return self.clients.claim();
      })
  );
});

// –ü–µ—Ä–µ—Ö–≤–∞—Ç –∑–∞–ø—Ä–æ—Å–æ–≤
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ç–∏–ø—ã –∑–∞–ø—Ä–æ—Å–æ–≤
  if (request.method !== 'GET') {
    return;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ API –∑–∞–ø—Ä–æ—Å–æ–≤
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleApiRequest(request));
    return;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
  if (isStaticAsset(url.pathname)) {
    event.respondWith(handleStaticRequest(request));
    return;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏ –≤–∏–¥–µ–æ
  if (isMediaAsset(url.pathname)) {
    event.respondWith(handleMediaRequest(request));
    return;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
  if (request.mode === 'navigate') {
    event.respondWith(handleNavigationRequest(request));
    return;
  }

  // Fallback –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
  event.respondWith(handleFallbackRequest(request));
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ API –∑–∞–ø—Ä–æ—Å–æ–≤ (Network First)
async function handleApiRequest(request) {
  const url = new URL(request.url);
  
  try {
    // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–µ—Ç–∏
    const networkResponse = await fetch(request);
    
    // –ö—ç—à–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã
    if (networkResponse.ok) {
      const cache = await caches.open(API_CACHE);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.log('Service Worker: Network failed, trying cache for API request');
    
    // –ï—Å–ª–∏ —Å–µ—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫—ç—à–∞
    const cachedResponse = await caches.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º fallback –æ—Ç–≤–µ—Ç
    return new Response(
      JSON.stringify({ 
        error: 'Network unavailable', 
        message: '–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É' 
      }),
      {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (Cache First)
async function handleStaticRequest(request) {
  const cachedResponse = await caches.match(request);
  
  if (cachedResponse) {
    return cachedResponse;
  }
  
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      const cache = await caches.open(STATIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º fallback –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
    if (request.destination === 'document') {
      return caches.match('/offline');
    }
    
    throw error;
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ (Stale While Revalidate)
async function handleMediaRequest(request) {
  const cachedResponse = await caches.match(request);
  
  // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –≤ —Ñ–æ–Ω–µ
  const fetchPromise = fetch(request).then((networkResponse) => {
    if (networkResponse.ok) {
      const cache = caches.open(DYNAMIC_CACHE);
      cache.then((c) => c.put(request, networkResponse.clone()));
    }
    return networkResponse;
  }).catch(() => {
    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ —Å–µ—Ç–∏ –¥–ª—è —Ñ–æ–Ω–æ–≤–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
  });
  
  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ –∂–¥–µ–º —Å–µ—Ç—å
  return cachedResponse || fetchPromise;
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
async function handleNavigationRequest(request) {
  try {
    // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Å–≤–µ–∂—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    // –ï—Å–ª–∏ —Å–µ—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º offline —Å—Ç—Ä–∞–Ω–∏—Ü—É
    const offlineResponse = await caches.match('/offline');
    if (offlineResponse) {
      return offlineResponse;
    }
    
    // Fallback HTML –¥–ª—è offline —Ä–µ–∂–∏–º–∞
    return new Response(
      `
      <!DOCTYPE html>
      <html lang="ru">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>MebelPlace - –û—Ñ–ª–∞–π–Ω</title>
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
          }
          .container {
            max-width: 400px;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
          }
          h1 { margin-bottom: 20px; }
          p { margin-bottom: 30px; opacity: 0.8; }
          button {
            background: #FF6600;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
          }
          button:hover { background: #FF8533; }
        </style>
      </head>
      <body>
        <div class="container">
          <h1>üîå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è</h1>
          <p>–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞</p>
          <button onclick="window.location.reload()">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å</button>
        </div>
      </body>
      </html>
      `,
      {
        headers: { 'Content-Type': 'text/html' }
      }
    );
  }
}

// Fallback –æ–±—Ä–∞–±–æ—Ç–∫–∞
async function handleFallbackRequest(request) {
  try {
    return await fetch(request);
  } catch (error) {
    const cachedResponse = await caches.match(request);
    return cachedResponse || new Response('Not found', { status: 404 });
  }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
function isStaticAsset(pathname) {
  return STATIC_ASSETS.includes(pathname) ||
         pathname.startsWith('/_next/static/') ||
         pathname.startsWith('/static/') ||
         pathname.endsWith('.js') ||
         pathname.endsWith('.css') ||
         pathname.endsWith('.woff2') ||
         pathname.endsWith('.woff') ||
         pathname.endsWith('.ttf');
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ–¥–∏–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
function isMediaAsset(pathname) {
  return pathname.match(/\.(jpg|jpeg|png|gif|webp|svg|mp4|webm|ogg)$/i);
}

// –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∫—ç—à–µ–π
async function cleanupOldCaches() {
  const cacheNames = await caches.keys();
  const oldCaches = cacheNames.filter(name => 
    name.startsWith('mebelplace-') && 
    name !== STATIC_CACHE && 
    name !== DYNAMIC_CACHE && 
    name !== API_CACHE
  );
  
  await Promise.all(
    oldCaches.map(cacheName => caches.delete(cacheName))
  );
}

// –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∫—ç—à–∞
async function limitCacheSize(cacheName, maxItems) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  
  if (keys.length > maxItems) {
    const keysToDelete = keys.slice(0, keys.length - maxItems);
    await Promise.all(keysToDelete.map(key => cache.delete(key)));
  }
}

// –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤ —Ñ–æ–Ω–µ
self.addEventListener('sync', (event) => {
  console.log('Service Worker: Background sync triggered', event.tag);
  
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync());
  }
});

// –§–æ–Ω–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è
async function doBackgroundSync() {
  try {
    // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö
    console.log('Service Worker: Performing background sync');
    
    // –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∫—ç—à–µ–π
    await cleanupOldCaches();
    
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∫—ç—à–µ–π
    await limitCacheSize(DYNAMIC_CACHE, MAX_CACHE_SIZE);
    await limitCacheSize(API_CACHE, MAX_CACHE_SIZE);
    
  } catch (error) {
    console.error('Service Worker: Background sync failed', error);
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ push —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
self.addEventListener('push', (event) => {
  console.log('Service Worker: Push notification received');
  
  if (event.data) {
    const data = event.data.json();
    
    const options = {
      body: data.body || '–ù–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç MebelPlace',
      icon: '/icon-192x192.png',
      badge: '/icon-192x192.png',
      vibrate: [200, 100, 200],
      data: data.data || {},
      actions: data.actions || [
        {
          action: 'view',
          title: '–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å',
          icon: '/icon-192x192.png'
        },
        {
          action: 'dismiss',
          title: '–ó–∞–∫—Ä—ã—Ç—å'
        }
      ],
      requireInteraction: data.requireInteraction || false,
      tag: data.tag || 'mebelplace-notification',
      renotify: data.renotify || false
    };
    
    event.waitUntil(
      self.registration.showNotification(data.title || 'MebelPlace', options)
    );
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –ø–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º
self.addEventListener('notificationclick', (event) => {
  console.log('Service Worker: Notification clicked');
  
  event.notification.close();
  
  if (event.action === 'view') {
    event.waitUntil(
      clients.openWindow('/')
    );
  } else if (event.action === 'dismiss') {
    // –ü—Ä–æ—Å—Ç–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  } else {
    // –ö–ª–∏–∫ –ø–æ —Å–∞–º–æ–º—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é
    event.waitUntil(
      clients.matchAll().then(clientList => {
        if (clientList.length > 0) {
          return clientList[0].focus();
        }
        return clients.openWindow('/');
      })
    );
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞
self.addEventListener('message', (event) => {
  console.log('Service Worker: Message received', event.data);
  
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'GET_VERSION') {
    event.ports[0].postMessage({ version: CACHE_NAME });
  }
});

console.log('Service Worker: Loaded successfully');